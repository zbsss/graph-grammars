import math
from utils.square import Square
from utils.vertex import Vertex, VertexLabel
from utils.graph_fragment import GraphFragment
import networkx as nx
import networkx.algorithms.isomorphism as iso

"""
_BETWEEN_LAYER_BUFFER - constant value which defines space between given graph layers
graph_vertices_id_counter - vertices counter which assigns ID to each vertex
_start_vertex - first vertex of the graph
_start_fragment - first fragment of the graph
vertices_graph_fragment - list of all vertices which allows you to generate graph fragments on the lower layer
graph_fragment_list - list of all graph fragments generated by productions
inter_layer_connections - list of all connections between upper and lower layers
"""
_BETWEEN_LAYER_BUFFER = 1  # possible to modify
graph_vertices_id_counter = 1
_start_vertex = Vertex(0, 0, 0, VertexLabel.I)
_start_fragment = GraphFragment([], [_start_vertex], -1, [], _start_vertex)
vertices_graph_fragment = {0: _start_fragment}
graph_fragment_list = [_start_fragment]
inter_layer_connections = []
split_nodes = False

def set_split_nodes(val):
    global split_nodes
    split_nodes = val

def fix_nodes_id():
    global graph_fragment_list
    for frag in graph_fragment_list:
        for id, ed in enumerate(frag.edges):
            e0 = ed[0]
            e1 = ed[1]
            frag.edges[id] = (min(e0, e1), max(e0, e1))
            

def _resolve_row_for_square(square):
    """
    Function which returns row for given single square
    """
    divider = 2 ** square.layer_number
    return square.field_id // divider


def _resolve_column_for_square(square):
    """
    Function which returns column for given single square
    """
    divider = 2 ** square.layer_number
    return square.field_id % divider


def _resolve_upper_left_lower_layer_square_id(square_row, square_column, square):
    """
    Function which returns ID of upper left square on the lower layer 
    """
    return square_row * (2 ** (square.layer_number + 2)) + (square_column * 2)


def _resolve_lower_left_lower_layer_square_id(square_row, square_column, square):
    """
    Function which returns ID of lower left square on the lower layer 
    """
    return (square_row * (2 ** (square.layer_number + 2)) + (square_column * 2)) + (2 ** (square.layer_number + 1))


def _append_generated_lower_layer_squares(square, lower_layer_squares):
    """
    Function which generates 4 squares on lower layer for each square from upper layer 
    and appends these 4 squares to lower_layer_squares list
    """
    lower_square_layer = square.layer_number + 1
    square_row = _resolve_row_for_square(square)
    square_column = _resolve_column_for_square(square)
    upper_left_lower_layer_square_id = _resolve_upper_left_lower_layer_square_id(square_row, square_column, square)
    upper_right_lower_layer_square_id = upper_left_lower_layer_square_id + 1
    lower_left_lower_layer_square_id = _resolve_lower_left_lower_layer_square_id(square_row, square_column, square)
    lower_right_lower_layer_square_id = lower_left_lower_layer_square_id + 1
    lower_layer_squares.append(Square(upper_left_lower_layer_square_id, lower_square_layer))
    lower_layer_squares.append(Square(upper_right_lower_layer_square_id, lower_square_layer))
    lower_layer_squares.append(Square(lower_left_lower_layer_square_id, lower_square_layer))
    lower_layer_squares.append(Square(lower_right_lower_layer_square_id, lower_square_layer))


def _resolve_vertices_coordinates_for_square(square):
    """
    Function which returns coordinates for all vertexs of a single square 
    """
    global graph_vertices_id_counter
    square_layer = square.layer_number
    acc = -_BETWEEN_LAYER_BUFFER
    for i in range(square_layer):
        layer_size = (2 ** i)
        acc -= (layer_size + _BETWEEN_LAYER_BUFFER)
    breaks = 0
    if square_layer > 2:
        for i in range(2, square_layer):
            layer_size = (2 ** (i - 1))
            breaks = layer_size - 1
    acc -= breaks
    square_row = _resolve_row_for_square(square)
    square_column = _resolve_column_for_square(square)
    global split_nodes

    if(split_nodes):
        # removed breaks between columns to allow merging fragments
        y_upper_left_vertex = acc - square_row - (square_row // 2)
        x_upper_left_vertex = square_column + (square_column // 2)
    else:
        y_upper_left_vertex = acc - square_row
        x_upper_left_vertex = square_column
    square.vertices.append(
        Vertex(x_upper_left_vertex, y_upper_left_vertex, graph_vertices_id_counter, VertexLabel.UNDEFINED))
    graph_vertices_id_counter += 1
    square.vertices.append(
        Vertex(x_upper_left_vertex + 1, y_upper_left_vertex, graph_vertices_id_counter, VertexLabel.UNDEFINED))
    graph_vertices_id_counter += 1
    square.vertices.append(
        Vertex(x_upper_left_vertex, y_upper_left_vertex - 1, graph_vertices_id_counter, VertexLabel.UNDEFINED))
    graph_vertices_id_counter += 1
    square.vertices.append(Vertex(x_upper_left_vertex + 1, y_upper_left_vertex - 1, graph_vertices_id_counter,
                                    VertexLabel.UNDEFINED))
    graph_vertices_id_counter += 1
    square.vertices.append(Vertex(x_upper_left_vertex + 0.5, y_upper_left_vertex - 0.5, graph_vertices_id_counter,
                                    VertexLabel.UNDEFINED))
    graph_vertices_id_counter += 1


def resolve_lower_layer_squares(graph_fragment):
    """
    Function which returns all single squares for all graph fragments generated on the right side of the production
    """
    squares_list = graph_fragment.squares
    lower_layer_squares = []
    if len(squares_list) == 0:
        lower_layer_squares.append(Square(0, 0))
        _resolve_vertices_coordinates_for_square(lower_layer_squares[0])
        return lower_layer_squares
    for square in squares_list:
        _append_generated_lower_layer_squares(square, lower_layer_squares)
    for square in lower_layer_squares:
        _resolve_vertices_coordinates_for_square(square)
    return lower_layer_squares


def find_lower_left_vertex(lower_layer_squares):
    """
    Function which returns lower left vertex from lower_layer_squares list
    """
    min_square_vertex = None
    for square in lower_layer_squares:
        for vertex in square.vertices:
            if min_square_vertex is None or min_square_vertex.x > vertex.x or min_square_vertex.y > vertex.y:
                min_square_vertex = vertex
    return min_square_vertex


def find_vertex_with_coordinates_and_remove_duplicates(x, y, lower_layer_squares):
    """
    Function which returns a vertex for coordinates and removes 
    its duplicates (other objects representing vertex with the same coords) from neighbouring squares
    """
    result_vertex = None
    vertices_to_delete = []
    for square in lower_layer_squares:
        for vertex in square.vertices:
            if vertex.x == x and vertex.y == y:
                if result_vertex is None:
                    result_vertex = vertex
                else:
                    vertices_to_delete.append(vertex)
    for vertex_to_delete in vertices_to_delete:
        for square in lower_layer_squares:
            if vertex_to_delete in square.vertices:
                square.vertices.remove(vertex_to_delete)
                square.vertices.append(result_vertex)
    return result_vertex


def return_graph_fragment_squares_from_upper_left_square(lower_layer_squares, upper_left_square):
    """
    Function which returns all single squares located in upper left square
    """
    result_squares = []
    upper_left_square_column = _resolve_column_for_square(upper_left_square)
    upper_left_square_row = _resolve_row_for_square(upper_left_square)
    lower_layer_width = math.sqrt(len(lower_layer_squares)) / 2
    for square in lower_layer_squares:
        if (_resolve_row_for_square(square) >= upper_left_square_row and _resolve_row_for_square(
                square) < upper_left_square_row + lower_layer_width and upper_left_square_column <= _resolve_column_for_square(
            square) < upper_left_square_column + lower_layer_width):
            result_squares.append(square)
    return result_squares


def set_labels_in_graph_fragment(graph_fragment):
    """
    Function which sets labels in graph fragment
    """
    for vertex in graph_fragment.vertices:
        vertex.label = VertexLabel.E
    graph_fragment.middle_vertex.label = VertexLabel.I
    

def yield_fragment_edges():
    """ Yields edges in graph_fragment_list """
    for fragment in graph_fragment_list:
        for edge in fragment.edges:
            yield edge

def yield_layer_connections_edges():
    """ Yields edges between layers """
    for layer_connections in inter_layer_connections:
        yield layer_connections

def yield_all_edges():
    """ Yields all edges """
    yield from yield_fragment_edges()
    yield from yield_layer_connections_edges()

def yield_all_vertices():
    """ Yields all vertices """
    for fragment in graph_fragment_list:
        for vertex in fragment.vertices:
            yield vertex


def merge_vertices(vertices):
    """
    Merges provided verticies leaving only the one with smallest ID
    """
    vertices.sort()
    smallest = min(vertices)
    for fragment in graph_fragment_list:    # recconnect edges
        for id,edge in enumerate(fragment.edges):
            if(edge[0] in vertices):
                fragment.edges[id] = (smallest, edge[1])
            elif(edge[1] in vertices):
                fragment.edges[id] = (edge[0], smallest)

    for id, layer_connections in enumerate(inter_layer_connections):    # recconnect edges between layers
        if(layer_connections[0] in vertices):
            inter_layer_connections[id] = (smallest, layer_connections[1])
        elif(layer_connections[1] in vertices):
            inter_layer_connections[id] = (layer_connections[0], smallest)

    vertices.remove(smallest)
    for fragment in graph_fragment_list:    # remove vertices stored in fragments
        vertices_to_remove = []
        for vert in fragment.vertices:
            if(vert.id in vertices):
                vertices_to_remove.append(vert)
        for vert in vertices_to_remove:
            fragment.vertices.remove(vert)
    
    for fragment in graph_fragment_list:    # recconnect edges
        for i in range(len(fragment.edges)):
            fragment.edges[i] = (min(fragment.edges[i][0], fragment.edges[i][1]), max(fragment.edges[i][0], fragment.edges[i][1]))

def find_vertex_with_id(vert_id : int) -> Vertex:
    """ Returns vertex object from given id """
    for vertex in yield_all_vertices():
        if(vertex.id == vert_id):
            return vertex


def get_lower_left_vertice_in_graph_fragment(graph_fragment: GraphFragment) -> Vertex:
    for v in graph_fragment.vertices:
        if v.x < graph_fragment.middle_vertex.x and v.y < graph_fragment.middle_vertex.y:
            return v


def get_lower_right_vertice_in_graph_fragment(graph_fragment: GraphFragment) -> Vertex:
    for v in graph_fragment.vertices:
        if v.x > graph_fragment.middle_vertex.x and v.y < graph_fragment.middle_vertex.y:
            return v


def get_upper_left_vertice_in_graph_fragment(graph_fragment: GraphFragment) -> Vertex:
    for v in graph_fragment.vertices:
        if v.y > graph_fragment.middle_vertex.y and v.x < graph_fragment.middle_vertex.x:
            return v


def get_upper_right_vertice_in_graph_fragment(graph_fragment: GraphFragment) -> Vertex:
    for v in graph_fragment.vertices:
        if v.x > graph_fragment.middle_vertex.x and v.y > graph_fragment.middle_vertex.y:
            return v


def merge_verticies(right_vertex : Vertex, left_vertex : Vertex, graphFregments):
    """
    merges two vertices into one, and removes edges
    """
    for graphFragment in graphFregments:
        to_remove = []
        to_append = []

        for (a, b) in graphFragment.edges:
            if a == right_vertex.id:
                to_remove.append((a, b))
                to_append.append((left_vertex.id, b))
            if b == right_vertex.id:
                to_remove.append((a, b))
                to_append.append((a, left_vertex.id))

        for t in to_remove:
            graphFragment.edges.remove(t)

        for t in to_append:
            graphFragment.edges.append(t)


        for a in graphFragment.vertices:
            if a.id == right_vertex.id:
                graphFragment.vertices.remove(a)
                break

        graphFragment.vertices.append(left_vertex)

def is_middle_vertex_correct(frag: GraphFragment) -> bool:
    """
    This function checks if the middle vertex is properly placed, and has correct label
    """
    middle_vertex = frag.middle_vertex
    others = [vertex for vertex in frag.vertices if vertex.id != middle_vertex.id]
    middle_x = 0
    middle_y = 0
    for vertex in others:
        middle_x += vertex.x
        middle_y += vertex.y
    middle_y /= len(others)
    middle_x /= len(others)

    return middle_vertex.x == middle_x and middle_vertex.y == middle_y and middle_vertex.label == VertexLabel.I

def compare_vertices(vertex_a: Vertex, vertex_b: Vertex):
    """
    This function check if vertex coordinates are the same
    """
    return vertex_a.x == vertex_b.x and vertex_a.y == vertex_b.y

def is_graph_isomorphic(frag: GraphFragment):
    """
    checks whether the given graph fragment is isomorphic with the default graph
    A - - - B
    | \   / |
    |   C   |
    | /   \ |
    D - - - E
    """
    default_graph = nx.Graph()
    default_graph.add_nodes_from(list(range(5)))
    default_graph.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 2), (1, 4), (2, 3), (2, 4), (3, 4)])

    graph_to_check = nx.Graph()
    vert_ids = list(map(lambda v: v.id, frag.vertices))
    graph_to_check.add_nodes_from(vert_ids)
    graph_to_check.add_edges_from(frag.edges)
    return iso.is_isomorphic(graph_to_check, default_graph)

def check_vertices_label(graph_fragment: GraphFragment):
    labels_on_edge = [vertex.label for vertex in graph_fragment.vertices if vertex.id != graph_fragment.middle_vertex.id]
    return all(map(lambda x: x == VertexLabel.E, labels_on_edge))

def reset_global_state():
    """
    resets global state
    """
    global vertices_graph_fragment
    global graph_fragment_list
    global inter_layer_connections
    global graph_vertices_id_counter
    _start_vertex = Vertex(0, 0, 0, VertexLabel.I)
    _start_fragment = GraphFragment([], [_start_vertex], -1, [], _start_vertex)
    vertices_graph_fragment.clear()
    vertices_graph_fragment[0] = _start_fragment
    graph_fragment_list.clear()
    graph_fragment_list.append(_start_fragment)
    inter_layer_connections.clear()
    graph_vertices_id_counter = 1